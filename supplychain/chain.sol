pragma solidity >=0.4.24;

// inherit contracts 
import '../accesscontrol/Ownable.sol';
import '../accesscontrol/Farmer.sol';
import '../accesscontrol/Distributor.sol';
import '../accesscontrol/Manufacturer.sol';
import '../accesscontrol/Retailer.sol';
import '../accesscontrol/Consumer.sol'; 


// Contract: Supply Chain
contract SupplyChain is Ownable, Farmer, DistributorRole, ManufacturerRole, RetailerRole, ConsumerRole {
    // owner
    address owner; 

    // Universal Product Code 
    uint upc;

    // Stock Keeping Unit
    uint sku;

    // Define where we are in the chain
    enum State {
        ProduceByFarmer,             //1
        ForSaleByFarmer,             //2
        PurchasedByDistributor,      //3   
        ShippedByFarmer,             //4
        ReceivedByDistributor,       //5
        ProcessedByDistributor,      //6
        PackageByDistributor,        //7
        ForSaleByDistributor,        //8
        PurchasedByManufacturer,     //9
        ShippedByDistributor,        //10
        ReceivedByManufacturer,      //11
        ProcessedByManufacturer,     //12
        PackageByManufacturer,       //13
        ForSaleByManufacturer,       //14
        PurchasedByRetailer,         //15
        ShippedByManufacturer,       //16
        ReceivedByRetailer,          //17
        ForSaleByRetailer,           //18
        PurchasedByConsumer          //19
    }

    State constant defaultState = State.ProduceByFarmer;

    // Item struct with relevant variables:
    // POTENTIALLY TRACK MORE VARIABLES 

    struct Item {
        uint    sku;                    // Stock Keeping Unit (SKU)
        uint    upc;                    // Generated by Farmer -> can be verified by Consumer
        address ownerID;                // Metamask-Ethereum address of the current owner as the product moves through stages
        address originFarmerID;         // Metamask-Ethereum address of the Farmer
        string  originFarmName;         // Farmer Name
        State   itemState;              // Product State as represented in the enum above
        uint    productPrice;           // Product Price
        address distributorID;          // Metamask-Ethereum address of the Distributor
        address manufacturerID;         // Metamask-Ethereum address of the Manufacturer
        address retailerID;             // Metamask-Ethereum address of the Retailer
        address consumerID;             // Metamask-Ethereum address of the Consumer
    }

    // public mapping: maps UPC to an item
    mapping (uint => Item) items;  

    // Block number stuct
    struct Txblocks {
        uint FTD; // blockfarmerToDistributor
        uint DTM; // blockDistributorToManufacturer
        uint MTR; // blockManufacturerToRetailer
        uint RTC; // blockRetailerToConsumer
    }

    // track its an item's journey through the supply chain -- to be sent from DApp.
    mapping (uint => Txblocks) itemsHistory;


    // Define events to listen to
    event ProduceByFarmer(uint upc);              //1
    event ForSaleByFarmer(uint upc);              //2
    event PurchasedByDistributor(uint upc);       //3   
    event ShippedByFarmer(uint upc);              //4
    event ReceivedByDistributor(uint upc);        //5
    event ProcessedByDistributor(uint upc);       //6
    event PackageByDistributor(uint upc);         //7
    event ForSaleByDistributor(uint upc);         //8
    event PurchasedByManufacturer(uint upc);      //9
    event ShippedByDistributor(uint upc);         //10
    event ReceivedByManufacturer(uint upc);       //11
    event ProcessedByManufacturer(uint upc);      //12
    event PackageByManufacturer(uint upc);        //13
    event ForSaleByManufacturer(uint upc);        //14
    event PurchasedByRetailer(uint upc);          //15
    event ShippedByManufacturer(uint upc);        //16
    event ReceivedByRetailer(uint upc);           //17
    event ForSaleByRetailer(uint upc);            //18
    event PurchasedByConsumer(uint upc);          //19

    // Checks & Requirements

    // Modifier = automatically check a condition prior to executing the function
    
    // Define a modifer that verifies the Caller
    modifier verifyCaller (address _address) {
        require(msg.sender == _address,
        "Only with valid address possible"
        );
        _;
    }
    
    // Define a modifier that checks if the paid amount is sufficient to cover the price
    modifier paidEnough(uint _price) {
        require(msg.value >= _price,
        "Not enough money paid"
        );
        _;
    }

    // Define a modifier that checks the price and refunds the remaining balance
    modifier checkValue(uint _upc, address payable addressToFund) {
        uint _price = items[_upc].productPrice;
        uint  amountToReturn = msg.value - _price;
        addressToFund.transfer(amountToReturn);
        _;
    }


    // Item State Modifiers
    // 1
    modifier producedByFarmer(uint _upc) {
        require(items[_upc].itemState == State.ProduceByFarmer);
        _;
    }
    // 2
    modifier forSaleByFarmer(uint _upc) {
        require(items[_upc].itemState == State.ForSaleByFarmer);
        _;
    }
    // 3
    modifier purchasedByDistributor(uint _upc) {
        require(items[_upc].itemState == State.PurchasedByDistributor);
        _;
    }
    // 4
    modifier shippedByFarmer(uint _upc) {
        require(items[_upc].itemState == State.ShippedByFarmer);
        _;
    }
    // 5
    modifier receivedByDistributor(uint _upc) {
        require(items[_upc].itemState == State.ReceivedByDistributor);
        _;
    }
    // 6
    modifier processByDistributor(uint _upc) {
        require(items[_upc].itemState == State.ProcessedByDistributor);
        _;
    }
    // 7
    modifier packagedByDistributor(uint _upc) {
        require(items[_upc].itemState == State.PackageByDistributor);
        _;
    }
    // 8
    modifier forSaleByDistributor(uint _upc) {
        require(items[_upc].itemState == State.ForSaleByDistributor);
        _;
    }
    // 9
    modifier purchasedByManufacturer(uint _upc) {
        require(items[_upc].itemState == State.PurchasedByManufacturer);
        _;
    } 
    // 10
    modifier shippedByDistributor(uint _upc) {
        require(items[_upc].itemState == State.ShippedByDistributor);
        _;
    }
    // 11
    modifier receivedByManufacturer(uint _upc) {
        require(items[_upc].itemState == State.ReceivedByManufacturer);
        _;
    } 
    // 12
    modifier processedByManufacturer(uint _upc) {
        require(items[_upc].itemState == State.ProcessedByManufacturer);
        _;
    }
    // 13   
    modifier packageByManufacturer(uint _upc) {
        require(items[_upc].itemState == State.PackageByManufacturer);
        _;
    } 
    // 14
    modifier forSaleByManufacturer(uint _upc) {
        require(items[_upc].itemState == State.ForSaleByManufacturer);
        _;
    }
    // 15
    modifier purchasedByRetailer(uint _upc) {
        require(items[_upc].itemState == State.PurchasedByRetailer);
        _;
    }
    // 16
    modifier shippedByManufacturer(uint _upc) {
        require(items[_upc].itemState == State.ShippedByManufacturer);
        _;
    }
    // 17
    modifier receivedByRetailer(uint _upc) {
        require(items[_upc].itemState == State.ReceivedByRetailer);
        _;
    }
    // 18
    modifier forSaleByRetailer(uint _upc) {
        require(items[_upc].itemState == State.ForSaleByRetailer);
        _;
    }
    // 19
    modifier purchasedByConsumer(uint _upc) {
        require(items[_upc].itemState == State.PurchasedByConsumer);
        _;
    }

    // constructor setup owner sku upc
    constructor() payable {
        owner = msg.sender;
        sku = 1;
        upc = 1;
    }

    // allows you to convert an address into a payable address
    function _make_payable(address x) internal pure returns (address payable) {
        return address(uint160(x));
    }

    // Define a function 'kill'
    function kill() public {
        if (msg.sender == owner) {
        address payable ownerAddressPayable = _make_payable(owner);
        selfdestruct(ownerAddressPayable);
        }
    }

    /*
    1st step in supplychain
    Allows farmer to create choloclate 
    */
    function produceItemByFarmer(uint _upc, string memory _originFarmName, uint _price) public onlyFarmer(){
        address distributorID; // Empty distributorID address
        address manufacturerID; // Empty manufacturerID address
        address retailerID; // Empty retailerID address
        address consumerID; // Empty consumerID address

        Item memory newProduce; // Create a new struct Item in memory
        newProduce.sku = sku;  // Stock Keeping Unit (SKU)
        newProduce.upc = _upc; // Universal Product Code (UPC), generated by the Farmer, goes on the package, can be verified by the Consumer

        newProduce.ownerID = msg.sender;
        newProduce.originFarmerID = msg.sender;
        newProduce.originFarmName = _originFarmName;

        newProduce.itemState = defaultState;
        newProduce.productPrice = _price;  

        newProduce.distributorID = distributorID;
        newProduce.manufacturerID = manufacturerID;
        newProduce.retailerID = retailerID;
        newProduce.consumerID = consumerID;

        items[_upc] = newProduce;

        uint placeholder; // Block number place holder
        Txblocks memory txBlock;
        txBlock.FTD = placeholder;
        txBlock.DTM = placeholder;
        txBlock.MTR = placeholder;
        txBlock.RTC = placeholder;
        itemsHistory[_upc] = txBlock;

        // increment  sku
        sku = sku + 1;

        // Emit the appropriate event
        emit ProduceByFarmer(_upc);
    } 
    /*
    2nd step in supplychain
    Allows farmer to sell chocolate
    */
    function sellItemByFarmer(uint _upc, uint _price) public
        onlyFarmer() // check msg.sender belongs to farmerRole
        producedByFarmer(_upc) // check items state has been produced
        verifyCaller(items[_upc].ownerID) // check msg.sender is owner
        {
        items[_upc].itemState = State.ForSaleByFarmer;
        items[_upc].productPrice = _price;
        emit ForSaleByFarmer(_upc);
        }
    /*
    3rd step in supplychain
    Allows distributor to purchase chocolate
    */    
    function purchaseItemByDistributor(uint _upc) public payable
        onlyDistributor() // check msg.sender belongs to distributorRole
        forSaleByFarmer(_upc) // check items state is for ForSaleByFarmer
        paidEnough(items[_upc].productPrice) // check if distributor sent enough Ether for chocolate
        checkValue(_upc, msg.sender) // check if overpayed return remaing funds back to msg.sender
        {
        address payable ownerAddressPayable = _make_payable(items[_upc].originFarmerID); // make originFarmID payable
        ownerAddressPayable.transfer(items[_upc].productPrice); // transfer funds from distributor to farmer
        items[_upc].ownerID = msg.sender; // update owner
        items[_upc].distributorID = msg.sender; // update distributor
        items[_upc].itemState = State.PurchasedByDistributor; // update state
        itemsHistory[_upc].FTD = block.number; // add block number
        emit PurchasedByDistributor(_upc);
    }
    /*
    4th step in supplychain
    Allows farmer to ship cheese purchased by distributor
    */
    function shippedItemByFarmer(uint _upc) public payable
        onlyFarmer() // check msg.sender belongs to Farmer
        purchasedByDistributor(_upc)
        verifyCaller(items[_upc].originFarmerID) // check msg.sender is originFarmID
        {
        items[_upc].itemState = State.ShippedByFarmer; // update state
        emit ShippedByFarmer(_upc);
    }
    /*
    5th step in supplychain
    Allows distributor to receive chocolate
    */
    function receivedItemByDistributor(uint _upc) public
        onlyDistributor() // check msg.sender belongs to DistributorRole
        shippedByFarmer(_upc)
        verifyCaller(items[_upc].ownerID) // check msg.sender is owner
        {
        items[_upc].itemState = State.ReceivedByDistributor; // update state
        emit ReceivedByDistributor(_upc);
    }
    /*
    6th step in supplychain
    Allows distributor to process chocolate
    */
    function processedItemByDistributor(uint _upc) public
        onlyDistributor() // check msg.sender belongs to DistributorRole
        receivedByDistributor(_upc)
        verifyCaller(items[_upc].ownerID) // check msg.sender is owner
        {
        items[_upc].itemState = State.ProcessedByDistributor; // update state
        emit ProcessedByDistributor(_upc);
    }
    /*
    7th step in supplychain
    Allows distributor to package cheese
    */
    function packageItemByDistributor(uint _upc) public
        onlyDistributor() // check msg.sender belongs to DistributorRole
        processByDistributor(_upc)
        verifyCaller(items[_upc].ownerID) // check msg.sender is owner
        {
        items[_upc].itemState = State.PackageByDistributor;
        emit PackageByDistributor(_upc);
    }
    /*
    8th step in supplychain
    Allows distributor to sell cheese
    */
    function sellItemByDistributor(uint _upc, uint _price) public
        onlyDistributor() // check msg.sender belongs to DistributorRole
        packagedByDistributor(_upc)
        verifyCaller(items[_upc].ownerID) // check msg.sender is owner
        {
            items[_upc].itemState = State.ForSaleByDistributor;
            items[_upc].productPrice = _price;
            emit ForSaleByDistributor(upc);
    }
    /*
    9th step in supplychain
    Allows manufacturer to purchase chocolate
    */
    function purchaseItemByManufacturer(uint _upc) public payable
        onlyManufacturer() // check msg.sender belongs to ManufacturerRole
        forSaleByDistributor(_upc)
        paidEnough(items[_upc].productPrice)
        checkValue(_upc, msg.sender)
        {
            address payable ownerAddressPayable = _make_payable(items[_upc].manufacturerID);
            ownerAddressPayable.transfer(items[_upc].productPrice);
            items[_upc].ownerID = msg.sender;
            items[_upc].manufacturerID = msg.sender;
            items[_upc].itemState = State.PurchasedByManufacturer;
            itemsHistory[_upc].DTM = block.number;
            emit PurchasedByManufacturer(_upc);
        }
    /*
    10th step in supplychain
    Allows distributor to ship chocolate purchased by manufacturer
    */
    function shippedItemByDistributor(uint _upc) public payable
        onlyDistributor() // check msg.sender belongs to DistributorRole
        purchasedByManufacturer(_upc)
        verifyCaller(items[_upc].ownerID) // check msg.sender is originFarmID
        {
        items[_upc].itemState = State.ShippedByDistributor; // update state
        emit ShippedByDistributor(_upc);
    }
    /*
    11th step in supplychain
    Allows manufacturer to receive chocolate purchased by distributor
    */
    function receivedItemByManufacturer(uint _upc) public
        onlyManufacturer()
        shippedByDistributor(_upc)
        verifyCaller(items[_upc].ownerID) // check msg.sender is ownerID
    {
        items[_upc].itemState = State.ReceivedByManufacturer; // update state
        emit ReceivedByManufacturer(_upc);
    }
    /*
    12th step in supplychain
    Allows manufacturer to process chocolate
    */
    function processedItemByManufacturer(uint _upc) public
        onlyManufacturer() // check msg.sender belongs to ManufacturerRole
        receivedByManufacturer(_upc)
        verifyCaller(items[_upc].ownerID) // check msg.sender is owner
        {
        items[_upc].itemState = State.ProcessedByManufacturer; // update state
        emit ProcessedByManufacturer(_upc);
    }
    /*
    13th step in supplychain
    Allows manufacturer to package chocolate
    */
    function packageItemByManufacturer(uint _upc) public
        onlyManufacturer() // check msg.sender belongs to ManufacturerRole
        processedByManufacturer(_upc)
        verifyCaller(items[_upc].ownerID) // check msg.sender is owner
        {
        items[_upc].itemState = State.PackageByManufacturer;
        emit PackageByManufacturer(_upc);
    }
    /*
    14th step in supplychain
    Allows manufacturer to sell chocolate
    */
    function sellItemByManufacturer(uint _upc, uint _price) public
        onlyManufacturer() // check msg.sender belongs to ManufacturerRole
        packageByManufacturer(_upc)
        verifyCaller(items[_upc].ownerID) // check msg.sender is owner
        {
            items[_upc].itemState = State.ForSaleByManufacturer;
            items[_upc].productPrice = _price;
            emit ForSaleByManufacturer(upc);
    }
    /*
    15th step in supplychain
    Allows retailer to buy chocolate
    */
    function purchaseItemByRetailer(uint _upc) public payable
        onlyRetailer() // check msg.sender belongs to RetailerRole
        forSaleByManufacturer(_upc)
        paidEnough(items[_upc].productPrice)
        checkValue(_upc, msg.sender)
        {
        address payable ownerAddressPayable = _make_payable(items[_upc].distributorID);
        ownerAddressPayable.transfer(items[_upc].productPrice);
        items[_upc].ownerID = msg.sender;
        items[_upc].retailerID = msg.sender;
        items[_upc].itemState = State.PurchasedByRetailer;
        itemsHistory[_upc].MTR = block.number;
        emit PurchasedByRetailer(_upc);
    }
    /*
    16th step in supplychain
    Allows manfacturer to ship chocolate
    */   
    function shippedItemByManufacturer(uint _upc) public payable
        onlyManufacturer() // check msg.sender belongs to DistributorRole
        purchasedByRetailer(_upc)
        verifyCaller(items[_upc].ownerID) // check msg.sender is originFarmID
        {
        items[_upc].itemState = State.ShippedByManufacturer; // update state
        emit ShippedByManufacturer(_upc);
    }
    /*
    17th step in supplychain
    Allows retialer to receive chocolate from manufacturer
    */
    function receivedItemByRetailer(uint _upc) public
        onlyRetailer() // check msg.sender belongs to RetailerRole
        shippedByManufacturer(_upc)
        verifyCaller(items[_upc].ownerID) // check msg.sender is ownerID
        {
        items[_upc].itemState = State.ReceivedByRetailer;
        emit ReceivedByRetailer(_upc);
    }
    /*
    18th step in supplychain
    Allows retailer to sell chocolate
    */
    function sellItemByRetailer(uint _upc, uint _price) public
        onlyRetailer()  // check msg.sender belongs to RetailerRole
        receivedByRetailer(_upc)
        verifyCaller(items[_upc].ownerID) // check msg.sender is ownerID
        {
        items[_upc].itemState = State.ForSaleByRetailer;
        items[_upc].productPrice = _price;
        emit ForSaleByRetailer(_upc);
    }
    /*
    19th step in supplychain
    Allows retailer to sell chocolate
    */  
    function purchaseItemByConsumer(uint _upc) public payable
        onlyConsumer()  // check msg.sender belongs to ConsumerRole
        forSaleByRetailer(_upc)
        paidEnough(items[_upc].productPrice)
        checkValue(_upc, msg.sender)
        {
        items[_upc].consumerID = msg.sender;
        address payable ownerAddressPayable = _make_payable(items[_upc].retailerID);
        ownerAddressPayable.transfer(items[_upc].productPrice);
        items[_upc].ownerID = msg.sender;
        items[_upc].consumerID = msg.sender;
        items[_upc].itemState = State.PurchasedByConsumer;
        itemsHistory[_upc].RTC = block.number;
        emit PurchasedByConsumer(_upc);
    }


// Define a function 'fetchItemBufferOne' that fetches the data
  function fetchItemBufferOne(uint _upc) public view returns
    (
    uint    itemSKU,
    uint    itemUPC,
    address ownerID,
    address originFarmerID,
    string memory  originFarmName
    )
    {
    // Assign values to the parameters
    Item memory item = items[_upc];
    return 
    (
      item.sku,
      item.upc,
      item.ownerID,
      item.originFarmerID,
      item.originFarmName
    );
    }

 // Define a function 'fetchItemBufferTwo' that fetches the data
    function fetchItemBufferTwo(uint _upc) public view returns (
        uint    itemSKU,
        uint    itemUPC,
        uint    productPrice,
        State   itemState,
        address distributorID,
        address manufacturerID,
        address retailerID,
        address consumerID
    ) {
        // Assign values to the 9 parameters
        Item memory item = items[_upc];
        return (
            item.sku,
            item.upc,
            item.productPrice,
            item.itemState,
            item.distributorID,
            item.manufacturerID,
            item.retailerID,
            item.consumerID
        );
    }

// Define a function 'fetchItemHistory' that fetches the data
  function fetchitemHistory(uint _upc) public view returns
    (
      uint blockfarmerToDistributor,
      uint blockDistributorToManufacturer,
      uint blockManufacturerToRetailer,
      uint blockRetailerToConsumer
    )
    {
      // Assign value to the parameters
      Txblocks memory txblock = itemsHistory[_upc];
      return
      (
        txblock.FTD,
        txblock.DTM,
        txblock.MTR,
        txblock.RTC
      );

    }



}
